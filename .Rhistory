library(tidyverse)
library(modelr)
library(scatterplot3d)
library(rsample)
library(rpart.plot)
library(caret)
library(quantmod)
library(modelr)
library(ISLR)
library(caret)
library(dplyr)
Cars<- read.csv("C:\\DARIA\\1.FSEGA\\AN_3\\FSEGA_3\\SEMESTRUL2\\BigData\\PROIECT\\CarsData.csv")
# Setarea nivelelor sa fie unice (pentru eroare)
all_engine_sizes <- unique(Cars$engineSize)
all_years <- unique(Cars$year)
all_transmissions <- unique(Cars$transmission)
all_manufacturers <- unique(Cars$Manufacturer)
Cars$engineSize <- factor(Cars$engineSize, levels = all_engine_sizes)
Cars$year <- factor(Cars$year, levels = all_years)
Cars$transmission <- factor(Cars$transmission, levels = all_transmissions)
Cars$Manufacturer <- factor(Cars$Manufacturer, levels = all_manufacturers)
Cars$model <- as.factor(Cars$model)
Cars$fuelType <- as.factor(Cars$fuelType)
Cars$tax <- as.factor(Cars$tax)
mod_price_all <- lm(price ~ ., data = Cars)
summary(mod_price_all)
# R = 11.95%
mod_price_model <- lm(price ~ model, data = Cars)
summary(mod_price_model)
mod_price_year <- lm(price ~ year, data = Cars)
summary(mod_price_year)
#......PRET IN FUNCTIE DE ENGINE, YEAR, TRANSMISSION, MODEL - SUMMARY - R = 87.79%
mod_price_complex <- lm(price ~ year + transmission + engineSize + model, data = Cars)
summary(mod_price_complex)
#......PRET IN FUNCTIE DE MANUFACTURER, MODEL - SUMMARY - R = 61.79%
mod_price_model_Manufacturer <- lm(price ~ Manufacturer + model, data = Cars)
summary(mod_price_model_Manufacturer)
set.seed(123)  # For reproducibility
split <- initial_split(Cars, prop = 0.7)
train_set <- training(split)
test_set <- testing(split)
Cars$engineSize <- factor(Cars$engineSize, levels = all_engine_sizes)
library(tidyverse)
library(modelr)
library(scatterplot3d)
library(rsample)
library(rpart.plot)
library(caret)
library(quantmod)
library(modelr)
library(ISLR)
library(caret)
library(dplyr)
# CITIRE DATE DIN CSV
Cars<- read.csv("C:\\DARIA\\1.FSEGA\\AN_3\\FSEGA_3\\SEMESTRUL2\\BigData\\PROIECT\\CarsData.csv")
# Setarea nivelelor sa fie unice (pentru eroare)
all_engine_sizes <- unique(Cars$engineSize)
all_years <- unique(Cars$year)
all_transmissions <- unique(Cars$transmission)
all_manufacturers <- unique(Cars$Manufacturer)
Cars$engineSize <- factor(Cars$engineSize, levels = all_engine_sizes)
Cars$year <- factor(Cars$year, levels = all_years)
Cars$transmission <- factor(Cars$transmission, levels = all_transmissions)
Cars$Manufacturer <- factor(Cars$Manufacturer, levels = all_manufacturers)
Cars$model <- as.factor(Cars$model)
Cars$fuelType <- as.factor(Cars$fuelType)
Cars$tax <- as.factor(Cars$tax)
m1 <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova"
)
set.seed(123)
cars_split <- initial_split(Cars, prop = 0.7)
cars_train <- training(cars_split)
cars_test <- testing(cars_split)
m1 <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova"
)
rpart.plot(m1)
plotcp(m1)
m1$cptable
m2 <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(cp = 0, xval = 10)  # se creste arborele pana la obtinerea valorii zero pentru parametrul alpha
)  # m2 este un arbore ne-taiat
plotcp(m2)
m3 <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = 10, maxdepth = 12, xval = 10)
)
m3
plotcp(m3)
rpart.plot(m3)
m3 <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = 10, maxdepth = 3, xval = 10)
)
m3
rpart.plot(m3)
plotcp(m3)
rpart.plot(m3)
plotcp(m3)
m3 <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = 10, maxdepth = 12, xval = 10)
)
plotcp(m3)
optimal_tree <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = 6, maxdepth = 13, cp = 0.0108982)
)
optimal_tree <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = 6, maxdepth = 13, cp = 0.0108982)
)
rpart.plot(optimat_tree)
optimal_tree <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = 6, maxdepth = 13, cp = 0.0108982)
)
rpart.plot(optimal_tree)
plotcp(optimal_tree)
plotcp(m3)
plotcp(optimal_tree)
pred <- predict(m1, newdata = cars_test)
RMSE(pred = pred, obs = cars_test$price)
optimal_tree
rpart.plot(m1)
pred <- predict(m1, newdata = cars_test)
RMSE(pred = pred, obs = cars_test$price)
#........ Continuare pentru primul m1 ..........
m2 <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(cp = 0, xval = 10)  # se creste arborele pana la obtinerea valorii zero pentru parametrul alpha
)  # m2 este un arbore ne-taiat
plotcp(m2)
abline(v = 12, lty = "dashed")
get_cp <- function(x) {
min <- which.min(x$cptable[,"xerror"])
cp <- x$cptable[min, "CP"]
}
get_min_error <- function(x) {
min <- which.min(x$cptable[, "xerror"])
xerror <- x$cptable[min, "xerror"]
}
mutated_grid <- hyper_grid %>%
mutate(
cp = purrr::map_dbl(models, get_cp),
error = purrr::map_dbl(models, get_min_error)
)
#cautam cele mai bune valori pentru parametri minsplit si maxdepth
hyper_grid <- expand.grid(
minsplit = seq(5, 20, 1),
maxdepth = seq(8, 15, 1)
)
head(hyper_grid)
models <- list()
for (i in 1:nrow(hyper_grid)) {
minsplit <- hyper_grid$minsplit[i]
maxdepth <- hyper_grid$maxdepth[i]
models[[i]] <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = minsplit, maxdepth = maxdepth)
)
}
#cautam cele mai bune valori pentru parametri minsplit si maxdepth
hyper_grid <- expand.grid(
minsplit = seq(5, 20, 1),
maxdepth = seq(8, 15, 1)
)
head(hyper_grid)
models <- list()
for (i in 1:nrow(hyper_grid)) {
minsplit <- hyper_grid$minsplit[i]
maxdepth <- hyper_grid$maxdepth[i]
models[[i]] <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = minsplit, maxdepth = maxdepth)
)
}
mutated_grid <- hyper_grid %>%
mutate(
cp = purrr::map_dbl(models, get_cp),
error = purrr::map_dbl(models, get_min_error)
)
#cautam cele mai bune valori pentru parametri minsplit si maxdepth
hyper_grid <- expand.grid(
minsplit = seq(5, 20, 1),
maxdepth = seq(8, 15, 1)
)
head(hyper_grid)
models <- list()
for (i in 1:nrow(hyper_grid)) {
minsplit <- hyper_grid$minsplit[i]
maxdepth <- hyper_grid$maxdepth[i]
models[[i]] <- rpart(
formula = price ~ .,
data = cars_train,
method = "anova",
control = list(minsplit = minsplit, maxdepth = maxdepth)
)
}
get_cp <- function(x) {
min <- which.min(x$cptable[,"xerror"])
cp <- x$cptable[min, "CP"]
}
get_min_error <- function(x) {
min <- which.min(x$cptable[, "xerror"])
xerror <- x$cptable[min, "xerror"]
}
mutated_grid <- hyper_grid %>%
mutate(
cp = purrr::map_dbl(models, get_cp),
error = purrr::map_dbl(models, get_min_error)
)
mutated_grid %>%
arrange(error) %>%
top_n(-5, wt=error)
library(tidyverse)
library(modelr)
library(scatterplot3d)
library(rsample)
library(rpart.plot)
library(caret)
library(quantmod)
library(modelr)
library(ISLR)
library(caret)
library(dplyr)
# CITIRE DATE DIN CSV
Cars<- read.csv("C:\\DARIA\\1.FSEGA\\AN_3\\FSEGA_3\\SEMESTRUL2\\BigData\\PROIECT\\CarsData.csv")
# CONVERTIRE VARIABILE IN FACTORI
# Setarea nivelelor sa fie unice (pentru eroare)
all_engine_sizes <- unique(Cars$engineSize)
all_years <- unique(Cars$year)
all_transmissions <- unique(Cars$transmission)
all_manufacturers <- unique(Cars$Manufacturer)
Cars$engineSize <- factor(Cars$engineSize, levels = all_engine_sizes)
Cars$year <- factor(Cars$year, levels = all_years)
Cars$transmission <- factor(Cars$transmission, levels = all_transmissions)
Cars$Manufacturer <- factor(Cars$Manufacturer, levels = all_manufacturers)
Cars$model <- as.factor(Cars$model)
Cars$fuelType <- as.factor(Cars$fuelType)
Cars$tax <- as.factor(Cars$tax)
